#!groovy

@Library(["rundeck", "toolbox-yaml"]) _

import groovy.json.JsonSlurperClassic
import java.text.SimpleDateFormat
import java.util.Calendar

def newVersionPublished = false

node('prod') {
    platformsList = prodtoolbox.getEnvironments('HES').join('\n')
}
pipeline {
    agent {
        node {
            label 'prod'
        }
    }
    triggers {
        // On évite 3h30 car c'est le créneau de lancement du script système dupdisk.sh - cf. https://jira.vsct.fr/browse/USL-1201
        parameterizedCron('''
30 2 * * 1-5 %PLATFORM=PRD6
 0 3 * * 1-5 %PLATFORM=PRD1
        ''')
    }
    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        disableConcurrentBuilds()
    }
    parameters {
        // Le premier choix est utilisé comme valeur par défaut, y compris lors de l'exécution cronnée :
        choice(choices: platformsList, name: "PLATFORM", description: "OBLIGATOIRE : Plateforme sur laquelle sera fait le déploiement")
        choice(choices: ['BOTH', 'BACK', 'FRONT'], name: "RESTART_COMPONENT")
        booleanParam(name: 'IGNORE_NEW_VERSION_CHECK', defaultValue: false)
    }
    stages {
        stage('Détection de nouvelle version') {
            steps {
                script {
                    if (params.IGNORE_NEW_VERSION_CHECK) {
                        newVersionPublished = true
                    } else {
                        newVersionPublished = (getLastVersionFromArtifact('hesperides/vsct-hesperides') != getCurrentBackendProdVersion(params.PLATFORM)
                                            || getLastVersionFromArtifact('hesperides/vsct-hesperides-gui') != getCurrentFrontendProdVersion(params.PLATFORM))
                    }
                }
            }
        }
        stage('Insertion en fresque OCC') {
            when { expression { newVersionPublished } }
            steps {
                script {
                    git(url: 'git@gitlab.socrate.vsct.fr:avengers/hesperides-tools.git', branch: 'master')
                    sh 'apt update -y && apt install -y python3 python3-pip'
                    sh 'python3 -m pip install requests'

                    String startTime = (new SimpleDateFormat("yyyy-MM-dd HH:mm")).format(new Date())
                    String endTime = (new SimpleDateFormat("yyyy-MM-dd HH:mm")).format(new Date(Calendar.getInstance().getTimeInMillis() + 10*60*1000))
                    String resume = "Déploiement sur ${params.PLATFORM} de la version backend=" + getLastVersionFromArtifact('hesperides/vsct-hesperides') + " frontend=" + getLastVersionFromArtifact('hesperides/vsct-hesperides-gui')
                    if (params.RESTART_COMPONENT != 'BOTH') {
                        resume += ' avec redémarrage du composant ' + params.RESTART_COMPONENT + ' uniquement'
                    }
                    withCredentials([usernamePassword(credentialsId: 'usl_ci', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
                        // Note : ce script prend en compte la variable $https_proxy définie dans l'environnement
                        sh "python3 occ_create.py --username ${env.USERNAME} --password ${env.PASSWORD} --type intervention --title '[Hesperides] Déploiement applicatif automatisé' --resume '${resume}' --start-date '${startTime}' --end-date '${endTime}' --status 1 --tag 10 --risk 3"
                    }
                }
            }
        }
        stage('Initialisation des Paramètres') {
            when { expression { newVersionPublished } }
            steps {
                script {
                    // Set params as they will be used later
                    platformContainers = readJSON(text: prodtoolbox.yPath("/HES/${params.PLATFORM}/DOCKER").toString()).result  // http://toolbox-server.socrate.vsct.fr/prod/api/toolbox?function=ypath&args=/HES/PRD1/DOCKER
                    dockerHosts = (platformContainers.HOSTS.collect { it.NAME } as List)[0]

                    // Set user
                    wrap([$class: 'BuildUser']) {
                        user = env.BUILD_USER_ID ?: 'jenkins'
                    }
                    rundeck.setRundeckUser(user)
                    // Set up Rundeck token
                    withCredentials([string(credentialsId: 'rundeck', variable: 'TOKEN')]) {
                        rundeck.setRundeckToken(TOKEN)
                    }
                }
            }
        }
        stage('Puppet refresh') {
            when { expression { newVersionPublished } }
            steps {
                script {
                    dockerHosts.each { hostname ->
                        echo "Refresh Puppet agent on ${hostname}"
                        Map optionsRundeck = [
                                refresh_puppet_agent: "complet",
                                serveur             : [hostname.toLowerCase()]
                        ]
                        rundeck.startAndWaitWithAutofill("HES", "Outils/refresh_puppet_agent", optionsRundeck)
                    }
                }
            }
        }
        stage('Restart Docker image') {
            when { expression { newVersionPublished } }
            steps {
                script {
                    for (dockerContainer in platformContainers) {
                        for (host in dockerContainer.HOSTS) {
                            for (instance in host.INSTANCES) {
                                if (params.RESTART_COMPONENT != 'BOTH' && !instance.NAME.endsWith(params.RESTART_COMPONENT)) {
                                    continue
                                }
                                echo "Restarting Docker instance ${instance.NAME} on ${host.NAME}"
                                rundeck.startAndWaitWithAutofill("HES", "Outils/restart_docker", [
                                        composant  : "DOCKER-${dockerContainer.IMAGE}",
                                        instances  : instance.NAME,
                                        trigramme  : 'HES',
                                        techno     : "DOCKER",
                                        TargetNodes: "HES${params.PLATFORM}DOCKER${dockerContainer.IMAGE}-${host.NAME}",
                                        plateforme : params.PLATFORM,
                                        serveur    : host.NAME.toLowerCase(),
                                ])
                            }
                            // On attend que les conteneurs front & back aient redémarrés avant de passer au suivant sur le même DC :
                            timeout(2) { // MINUTES
                                waitUntil {
                                    script {
                                        String endpoint = params.PLATFORM == 'PRD1' ? 'hesperides-dc1' : 'hesperides-dc2'
                                        String cookieValue = 'hes' + host.NAME.toLowerCase()[0..2] + (params.PLATFORM == 'PRD1' ? 'p1' : 'p6') + '1back'
                                        String cmd = "curl -skv -H 'Cookie: HES${params.PLATFORM}=${cookieValue}' https://${endpoint}.socrate.vsct.fr/rest/versions"
                                        echo cmd
                                        String output = sh(script:cmd, returnStdout:true).trim()
                                        echo output
                                        try {
                                            String hostname = new JsonSlurperClassic().parseText(output).HOSTNAME
                                            return hostname.toLowerCase() == host.NAME.toLowerCase()
                                        } catch (JsonException) {
                                            return false
                                        } catch (IllegalArgumentException) {
                                            return false
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    post {
        always {
            wrap([$class: 'MesosSingleUseSlave']) {}
            deleteDir()
        }
        failure {
            // Notification vers room Teams Avengers > Hefpérides
            office365ConnectorSend  status: currentBuild.currentResult, webhookUrl: 'https://outlook.office.com/webhook/838cfd20-344e-4053-97eb-5fa1f7fb25f9@85eca096-674d-4fd9-9a9e-ae1178e2ee56/IncomingWebhook/1999a50228794e95a1c17374a131da2e/56ceab7b-fee5-4173-882e-6504575c0bc8'
        }
    }
}

def getLastVersionFromArtifact(String imageName) {
    withCredentials([usernamePassword(credentialsId: 'hesperides', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
        String tags = sh(returnStdout: true, script: "curl --fail -su $USERNAME:$PASSWORD https://hesperides-docker-all-local.artifact.cloud.socrate.vsct.fr/v2/${imageName}/tags/list").trim()
        String version = new JsonSlurperClassic().parseText(tags).tags.findAll{ it.startsWith('20') }.last()
        println "Latest Artifact version for $imageName : $version"
        return version
    }
}

def getCurrentBackendProdVersion(String platform) {
    String endpoint = platform == 'PRD1' ? 'hesperides-dc1' : 'hesperides-dc2'
    String versions = sh(returnStdout: true, script: "curl --fail -sk https://${endpoint}.socrate.vsct.fr/rest/versions").trim()
    String gitTag = new JsonSlurperClassic().parseText(versions).GIT_TAG
    println "Current backend prod version on platform $platform : $gitTag"
    return gitTag
}

def getCurrentFrontendProdVersion(String platform) {
    String endpoint = platform == 'PRD1' ? 'hesperides-dc1' : 'hesperides-dc2'
    String version = sh(returnStdout: true, script: "curl --fail -sk https://${endpoint}.socrate.vsct.fr/index.html | grep -F ' GIT_TAG ' | sed 's/.*\\(20[0-9-]\\+\\).*/\\1/'").trim()
    println "Current frontend prod version on platform $platform : $version"
    return version
}
